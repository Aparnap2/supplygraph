# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class OrganizationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Organization]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Organization.prisma().query_raw(
            'SELECT * FROM Organization WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Organization
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Organization.prisma().query_first(
            'SELECT * FROM Organization WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrganizationCreateInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Organization record.

        Parameters
        ----------
        data
            Organization record data
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The created Organization record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Organization record from just the required fields
        organization = await Organization.prisma().create(
            data={
                # data to create a Organization record
                'name': 'ggciceaie',
                'slug': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrganizationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Organization records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Organization record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Organization.prisma().create_many(
            data=[
                {
                    # data to create a Organization record
                    'name': 'cadfabfehe',
                    'slug': 'dgiiaaijj',
                },
                {
                    # data to create a Organization record
                    'name': 'bfaiacjjfc',
                    'slug': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Organization record.

        Parameters
        ----------
        where
            Organization filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The deleted Organization record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Organization record.

        Parameters
        ----------
        where
            Organization filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The found Organization record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Organization record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Organization filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The found Organization record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Organization records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Organization records returned
        skip
            Ignore the first N results
        where
            Organization filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Organization]
            The list of all Organization records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Organization records
        organizations = await Organization.prisma().find_many(take=10)

        # find the first 5 Organization records ordered by the slug field
        organizations = await Organization.prisma().find_many(
            take=5,
            order={
                'slug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Organization record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Organization filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Organization
            The first Organization record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Organization record ordered by the logo field
        organization = await Organization.prisma().find_first(
            skip=1,
            order={
                'logo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Organization record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Organization filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Organization
            The first Organization record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Organization record ordered by the metadata field
        organization = await Organization.prisma().find_first_or_raise(
            skip=1,
            order={
                'metadata': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrganizationUpdateInput,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Organization record.

        Parameters
        ----------
        data
            Organization record data specifying what to update
        where
            Organization filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The updated Organization record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        organization = await Organization.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the Organization record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrganizationWhereUniqueInput,
        data: types.OrganizationUpsertInput,
        include: Optional[types.OrganizationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Organization filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The created or updated Organization record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'name': 'bfaiacjjfc',
                    'slug': 'eigcfgbif',
                },
                'update': {
                    'name': 'bfaiacjjfc',
                    'slug': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrganizationUpdateManyMutationInput,
        where: types.OrganizationWhereInput,
    ) -> int:
        """Update multiple Organization records

        Parameters
        ----------
        data
            Organization data to update the selected Organization records to
        where
            Filter to select the Organization records to update

        Returns
        -------
        int
            The total number of Organization records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Organization records
        total = await Organization.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Organization records present in the database

        Parameters
        ----------
        select
            Select the Organization fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Organization filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Organization.prisma().count()

        # results: prisma.types.OrganizationCountAggregateOutput
        results = await Organization.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrganizationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> types.OrganizationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrganizationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> Union[int, types.OrganizationCountAggregateOutput]:
        """Count the number of Organization records present in the database

        Parameters
        ----------
        select
            Select the Organization fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Organization filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Organization.prisma().count()

        # results: prisma.types.OrganizationCountAggregateOutput
        results = await Organization.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrganizationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrganizationWhereInput] = None
    ) -> int:
        """Delete multiple Organization records.

        Parameters
        ----------
        where
            Optional Organization filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Organization records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Organization records
        total = await Organization.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrganizationScalarFieldKeys'],
        *,
        where: Optional['types.OrganizationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrganizationAvgAggregateInput'] = None,
        sum: Optional['types.OrganizationSumAggregateInput'] = None,
        min: Optional['types.OrganizationMinAggregateInput'] = None,
        max: Optional['types.OrganizationMaxAggregateInput'] = None,
        having: Optional['types.OrganizationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrganizationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrganizationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrganizationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrganizationGroupByOutput']:
        """Group Organization records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Organization fields to group records by
        where
            Organization filter to select records
        take
            Limit the maximum number of Organization records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrganizationGroupByOutput]
            A list of dictionaries representing the Organization record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Organization records by name values
        # and count how many records are in each group
        results = await Organization.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'hjaecfifb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'bbejhfidcb',
                'orgId': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'bdiicjafbj',
                    'orgId': 'bgehebiafc',
                },
                {
                    # data to create a User record
                    'email': 'bghffegacj',
                    'orgId': 'bhghchehcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'dcgchcbbf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the name field
        users = await User.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the avatar field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'avatar': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the role field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'heejgedji',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bjgjgibgbf',
            },
            data={
                'create': {
                    'id': 'bjgjgibgbf',
                    'email': 'bghffegacj',
                    'orgId': 'bhghchehcc',
                },
                'update': {
                    'email': 'bghffegacj',
                    'orgId': 'bhghchehcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'isActive': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'orgId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by createdAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VendorActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Vendor]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Vendor.prisma().query_raw(
            'SELECT * FROM Vendor WHERE id = $1',
            'igbehcbab',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Vendor
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Vendor.prisma().query_first(
            'SELECT * FROM Vendor WHERE name = $1',
            'bdadaadhag',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VendorCreateInput,
        include: Optional[types.VendorInclude] = None
    ) -> _PrismaModelT:
        """Create a new Vendor record.

        Parameters
        ----------
        data
            Vendor record data
        include
            Specifies which relations should be loaded on the returned Vendor model

        Returns
        -------
        prisma.models.Vendor
            The created Vendor record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Vendor record from just the required fields
        vendor = await Vendor.prisma().create(
            data={
                # data to create a Vendor record
                'name': 'bgiggdidbf',
                'email': 'caaaedabfc',
                'orgId': 'bigibebcib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VendorCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Vendor records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Vendor record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Vendor.prisma().create_many(
            data=[
                {
                    # data to create a Vendor record
                    'name': 'bigaiehgcc',
                    'email': 'beeifcbebf',
                    'orgId': 'bgcigfahea',
                },
                {
                    # data to create a Vendor record
                    'name': 'bcejgaggif',
                    'email': 'idfjadbcc',
                    'orgId': 'hgdhbjhhj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VendorWhereUniqueInput,
        include: Optional[types.VendorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Vendor record.

        Parameters
        ----------
        where
            Vendor filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Vendor model

        Returns
        -------
        prisma.models.Vendor
            The deleted Vendor record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vendor = await Vendor.prisma().delete(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VendorWhereUniqueInput,
        include: Optional[types.VendorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Vendor record.

        Parameters
        ----------
        where
            Vendor filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vendor model

        Returns
        -------
        prisma.models.Vendor
            The found Vendor record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vendor = await Vendor.prisma().find_unique(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VendorWhereUniqueInput,
        include: Optional[types.VendorInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Vendor record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Vendor filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vendor model

        Returns
        -------
        prisma.models.Vendor
            The found Vendor record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vendor = await Vendor.prisma().find_unique_or_raise(
            where={
                'id': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VendorWhereInput] = None,
        cursor: Optional[types.VendorWhereUniqueInput] = None,
        include: Optional[types.VendorInclude] = None,
        order: Optional[Union[types.VendorOrderByInput, List[types.VendorOrderByInput]]] = None,
        distinct: Optional[List[types.VendorScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Vendor records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Vendor records returned
        skip
            Ignore the first N results
        where
            Vendor filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vendor model
        order
            Order the returned Vendor records by any field
        distinct
            Filter Vendor records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Vendor]
            The list of all Vendor records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Vendor records
        vendors = await Vendor.prisma().find_many(take=10)

        # find the first 5 Vendor records ordered by the email field
        vendors = await Vendor.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VendorWhereInput] = None,
        cursor: Optional[types.VendorWhereUniqueInput] = None,
        include: Optional[types.VendorInclude] = None,
        order: Optional[Union[types.VendorOrderByInput, List[types.VendorOrderByInput]]] = None,
        distinct: Optional[List[types.VendorScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Vendor record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vendor filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vendor model
        order
            Order the returned Vendor records by any field
        distinct
            Filter Vendor records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vendor
            The first Vendor record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vendor record ordered by the phone field
        vendor = await Vendor.prisma().find_first(
            skip=1,
            order={
                'phone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VendorWhereInput] = None,
        cursor: Optional[types.VendorWhereUniqueInput] = None,
        include: Optional[types.VendorInclude] = None,
        order: Optional[Union[types.VendorOrderByInput, List[types.VendorOrderByInput]]] = None,
        distinct: Optional[List[types.VendorScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Vendor record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vendor filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vendor model
        order
            Order the returned Vendor records by any field
        distinct
            Filter Vendor records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vendor
            The first Vendor record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vendor record ordered by the website field
        vendor = await Vendor.prisma().find_first_or_raise(
            skip=1,
            order={
                'website': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VendorUpdateInput,
        where: types.VendorWhereUniqueInput,
        include: Optional[types.VendorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Vendor record.

        Parameters
        ----------
        data
            Vendor record data specifying what to update
        where
            Vendor filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Vendor model

        Returns
        -------
        prisma.models.Vendor
            The updated Vendor record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vendor = await Vendor.prisma().update(
            where={
                'id': 'jjfeafhfj',
            },
            data={
                # data to update the Vendor record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VendorWhereUniqueInput,
        data: types.VendorUpsertInput,
        include: Optional[types.VendorInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Vendor filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Vendor model

        Returns
        -------
        prisma.models.Vendor
            The created or updated Vendor record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vendor = await Vendor.prisma().upsert(
            where={
                'id': 'cbachdgfce',
            },
            data={
                'create': {
                    'id': 'cbachdgfce',
                    'name': 'bcejgaggif',
                    'email': 'idfjadbcc',
                    'orgId': 'hgdhbjhhj',
                },
                'update': {
                    'name': 'bcejgaggif',
                    'email': 'idfjadbcc',
                    'orgId': 'hgdhbjhhj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VendorUpdateManyMutationInput,
        where: types.VendorWhereInput,
    ) -> int:
        """Update multiple Vendor records

        Parameters
        ----------
        data
            Vendor data to update the selected Vendor records to
        where
            Filter to select the Vendor records to update

        Returns
        -------
        int
            The total number of Vendor records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Vendor records
        total = await Vendor.prisma().update_many(
            data={
                'address': Json({'chbfcacbd': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VendorWhereInput] = None,
        cursor: Optional[types.VendorWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Vendor records present in the database

        Parameters
        ----------
        select
            Select the Vendor fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vendor filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VendorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vendor.prisma().count()

        # results: prisma.types.VendorCountAggregateOutput
        results = await Vendor.prisma().count(
            select={
                '_all': True,
                'orgId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VendorCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VendorWhereInput] = None,
        cursor: Optional[types.VendorWhereUniqueInput] = None,
    ) -> types.VendorCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VendorCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VendorWhereInput] = None,
        cursor: Optional[types.VendorWhereUniqueInput] = None,
    ) -> Union[int, types.VendorCountAggregateOutput]:
        """Count the number of Vendor records present in the database

        Parameters
        ----------
        select
            Select the Vendor fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vendor filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VendorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vendor.prisma().count()

        # results: prisma.types.VendorCountAggregateOutput
        results = await Vendor.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VendorCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VendorWhereInput] = None
    ) -> int:
        """Delete multiple Vendor records.

        Parameters
        ----------
        where
            Optional Vendor filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Vendor records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Vendor records
        total = await Vendor.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VendorScalarFieldKeys'],
        *,
        where: Optional['types.VendorWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VendorAvgAggregateInput'] = None,
        sum: Optional['types.VendorSumAggregateInput'] = None,
        min: Optional['types.VendorMinAggregateInput'] = None,
        max: Optional['types.VendorMaxAggregateInput'] = None,
        having: Optional['types.VendorScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VendorCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VendorScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VendorScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VendorGroupByOutput']:
        """Group Vendor records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Vendor fields to group records by
        where
            Vendor filter to select records
        take
            Limit the maximum number of Vendor records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VendorGroupByOutput]
            A list of dictionaries representing the Vendor record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Vendor records by isActive values
        # and count how many records are in each group
        results = await Vendor.prisma().group_by(
            ['isActive'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProcurementRequestActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProcurementRequest]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProcurementRequest.prisma().query_raw(
            'SELECT * FROM ProcurementRequest WHERE id = $1',
            'efggddide',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProcurementRequest
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProcurementRequest.prisma().query_first(
            'SELECT * FROM ProcurementRequest WHERE title = $1',
            'caficfigfb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProcurementRequestCreateInput,
        include: Optional[types.ProcurementRequestInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProcurementRequest record.

        Parameters
        ----------
        data
            ProcurementRequest record data
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model

        Returns
        -------
        prisma.models.ProcurementRequest
            The created ProcurementRequest record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProcurementRequest record from just the required fields
        procurementrequest = await ProcurementRequest.prisma().create(
            data={
                # data to create a ProcurementRequest record
                'title': 'bfidgijfjc',
                'items': Json({'ihieecagf': True}),
                'orgId': 'bghfciaafe',
                'createdBy': 'bgchfhgceh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProcurementRequestCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProcurementRequest records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProcurementRequest record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProcurementRequest.prisma().create_many(
            data=[
                {
                    # data to create a ProcurementRequest record
                    'title': 'cafeiaccbc',
                    'items': Json({'gaddfhfh': True}),
                    'orgId': 'gieegcbeg',
                    'createdBy': 'bgcffadich',
                },
                {
                    # data to create a ProcurementRequest record
                    'title': 'fcbichhci',
                    'items': Json({'bcggadccgf': True}),
                    'orgId': 'jdcfdcgc',
                    'createdBy': 'cafdaehjid',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProcurementRequestWhereUniqueInput,
        include: Optional[types.ProcurementRequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProcurementRequest record.

        Parameters
        ----------
        where
            ProcurementRequest filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model

        Returns
        -------
        prisma.models.ProcurementRequest
            The deleted ProcurementRequest record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        procurementrequest = await ProcurementRequest.prisma().delete(
            where={
                'id': 'gifdddbia',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProcurementRequestWhereUniqueInput,
        include: Optional[types.ProcurementRequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProcurementRequest record.

        Parameters
        ----------
        where
            ProcurementRequest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model

        Returns
        -------
        prisma.models.ProcurementRequest
            The found ProcurementRequest record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        procurementrequest = await ProcurementRequest.prisma().find_unique(
            where={
                'id': 'bchehecef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProcurementRequestWhereUniqueInput,
        include: Optional[types.ProcurementRequestInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProcurementRequest record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProcurementRequest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model

        Returns
        -------
        prisma.models.ProcurementRequest
            The found ProcurementRequest record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        procurementrequest = await ProcurementRequest.prisma().find_unique_or_raise(
            where={
                'id': 'jeijcbhfe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProcurementRequestWhereInput] = None,
        cursor: Optional[types.ProcurementRequestWhereUniqueInput] = None,
        include: Optional[types.ProcurementRequestInclude] = None,
        order: Optional[Union[types.ProcurementRequestOrderByInput, List[types.ProcurementRequestOrderByInput]]] = None,
        distinct: Optional[List[types.ProcurementRequestScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProcurementRequest records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProcurementRequest records returned
        skip
            Ignore the first N results
        where
            ProcurementRequest filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model
        order
            Order the returned ProcurementRequest records by any field
        distinct
            Filter ProcurementRequest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProcurementRequest]
            The list of all ProcurementRequest records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProcurementRequest records
        procurementrequests = await ProcurementRequest.prisma().find_many(take=10)

        # find the first 5 ProcurementRequest records ordered by the description field
        procurementrequests = await ProcurementRequest.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProcurementRequestWhereInput] = None,
        cursor: Optional[types.ProcurementRequestWhereUniqueInput] = None,
        include: Optional[types.ProcurementRequestInclude] = None,
        order: Optional[Union[types.ProcurementRequestOrderByInput, List[types.ProcurementRequestOrderByInput]]] = None,
        distinct: Optional[List[types.ProcurementRequestScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProcurementRequest record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProcurementRequest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model
        order
            Order the returned ProcurementRequest records by any field
        distinct
            Filter ProcurementRequest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProcurementRequest
            The first ProcurementRequest record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProcurementRequest record ordered by the items field
        procurementrequest = await ProcurementRequest.prisma().find_first(
            skip=1,
            order={
                'items': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProcurementRequestWhereInput] = None,
        cursor: Optional[types.ProcurementRequestWhereUniqueInput] = None,
        include: Optional[types.ProcurementRequestInclude] = None,
        order: Optional[Union[types.ProcurementRequestOrderByInput, List[types.ProcurementRequestOrderByInput]]] = None,
        distinct: Optional[List[types.ProcurementRequestScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProcurementRequest record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProcurementRequest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model
        order
            Order the returned ProcurementRequest records by any field
        distinct
            Filter ProcurementRequest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProcurementRequest
            The first ProcurementRequest record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProcurementRequest record ordered by the status field
        procurementrequest = await ProcurementRequest.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProcurementRequestUpdateInput,
        where: types.ProcurementRequestWhereUniqueInput,
        include: Optional[types.ProcurementRequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProcurementRequest record.

        Parameters
        ----------
        data
            ProcurementRequest record data specifying what to update
        where
            ProcurementRequest filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model

        Returns
        -------
        prisma.models.ProcurementRequest
            The updated ProcurementRequest record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        procurementrequest = await ProcurementRequest.prisma().update(
            where={
                'id': 'bjgejjabff',
            },
            data={
                # data to update the ProcurementRequest record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProcurementRequestWhereUniqueInput,
        data: types.ProcurementRequestUpsertInput,
        include: Optional[types.ProcurementRequestInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProcurementRequest filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProcurementRequest model

        Returns
        -------
        prisma.models.ProcurementRequest
            The created or updated ProcurementRequest record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        procurementrequest = await ProcurementRequest.prisma().upsert(
            where={
                'id': 'bcciijbibg',
            },
            data={
                'create': {
                    'id': 'bcciijbibg',
                    'title': 'fcbichhci',
                    'items': Json({'bcggadccgf': True}),
                    'orgId': 'jdcfdcgc',
                    'createdBy': 'cafdaehjid',
                },
                'update': {
                    'title': 'fcbichhci',
                    'items': Json({'bcggadccgf': True}),
                    'orgId': 'jdcfdcgc',
                    'createdBy': 'cafdaehjid',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProcurementRequestUpdateManyMutationInput,
        where: types.ProcurementRequestWhereInput,
    ) -> int:
        """Update multiple ProcurementRequest records

        Parameters
        ----------
        data
            ProcurementRequest data to update the selected ProcurementRequest records to
        where
            Filter to select the ProcurementRequest records to update

        Returns
        -------
        int
            The total number of ProcurementRequest records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProcurementRequest records
        total = await ProcurementRequest.prisma().update_many(
            data={
                'priority': enums.RequestPriority.LOW
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProcurementRequestWhereInput] = None,
        cursor: Optional[types.ProcurementRequestWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProcurementRequest records present in the database

        Parameters
        ----------
        select
            Select the ProcurementRequest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProcurementRequest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProcurementRequestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProcurementRequest.prisma().count()

        # results: prisma.types.ProcurementRequestCountAggregateOutput
        results = await ProcurementRequest.prisma().count(
            select={
                '_all': True,
                'orgId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProcurementRequestCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProcurementRequestWhereInput] = None,
        cursor: Optional[types.ProcurementRequestWhereUniqueInput] = None,
    ) -> types.ProcurementRequestCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProcurementRequestCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProcurementRequestWhereInput] = None,
        cursor: Optional[types.ProcurementRequestWhereUniqueInput] = None,
    ) -> Union[int, types.ProcurementRequestCountAggregateOutput]:
        """Count the number of ProcurementRequest records present in the database

        Parameters
        ----------
        select
            Select the ProcurementRequest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProcurementRequest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProcurementRequestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProcurementRequest.prisma().count()

        # results: prisma.types.ProcurementRequestCountAggregateOutput
        results = await ProcurementRequest.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProcurementRequestCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProcurementRequestWhereInput] = None
    ) -> int:
        """Delete multiple ProcurementRequest records.

        Parameters
        ----------
        where
            Optional ProcurementRequest filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProcurementRequest records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProcurementRequest records
        total = await ProcurementRequest.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProcurementRequestScalarFieldKeys'],
        *,
        where: Optional['types.ProcurementRequestWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProcurementRequestAvgAggregateInput'] = None,
        sum: Optional['types.ProcurementRequestSumAggregateInput'] = None,
        min: Optional['types.ProcurementRequestMinAggregateInput'] = None,
        max: Optional['types.ProcurementRequestMaxAggregateInput'] = None,
        having: Optional['types.ProcurementRequestScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProcurementRequestCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProcurementRequestScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProcurementRequestScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProcurementRequestGroupByOutput']:
        """Group ProcurementRequest records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProcurementRequest fields to group records by
        where
            ProcurementRequest filter to select records
        take
            Limit the maximum number of ProcurementRequest records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProcurementRequestGroupByOutput]
            A list of dictionaries representing the ProcurementRequest record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProcurementRequest records by approvedVendorId values
        # and count how many records are in each group
        results = await ProcurementRequest.prisma().group_by(
            ['approvedVendorId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class QuoteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Quote]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Quote.prisma().query_raw(
            'SELECT * FROM Quote WHERE id = $1',
            'cffcachfd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Quote
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Quote.prisma().query_first(
            'SELECT * FROM Quote WHERE orgId = $1',
            'bccdfhdigc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.QuoteCreateInput,
        include: Optional[types.QuoteInclude] = None
    ) -> _PrismaModelT:
        """Create a new Quote record.

        Parameters
        ----------
        data
            Quote record data
        include
            Specifies which relations should be loaded on the returned Quote model

        Returns
        -------
        prisma.models.Quote
            The created Quote record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Quote record from just the required fields
        quote = await Quote.prisma().create(
            data={
                # data to create a Quote record
                'orgId': 'febcgjbfj',
                'requestId': 'bageiegghg',
                'vendorId': 'faidicegb',
                'items': Json({'bacecgfhbe': True}),
                'totalAmount': Decimal('872078403.187474'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.QuoteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Quote records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Quote record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Quote.prisma().create_many(
            data=[
                {
                    # data to create a Quote record
                    'orgId': 'jbgijghgb',
                    'requestId': 'hgjcghfbi',
                    'vendorId': 'icadbcehj',
                    'items': Json({'jchciaee': True}),
                    'totalAmount': Decimal('344858293.112174'),
                },
                {
                    # data to create a Quote record
                    'orgId': 'bejfijgcfb',
                    'requestId': 'caifcbgii',
                    'vendorId': 'igaibbfgj',
                    'items': Json({'bggajdcbbi': True}),
                    'totalAmount': Decimal('525761943.73620'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.QuoteWhereUniqueInput,
        include: Optional[types.QuoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Quote record.

        Parameters
        ----------
        where
            Quote filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Quote model

        Returns
        -------
        prisma.models.Quote
            The deleted Quote record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quote = await Quote.prisma().delete(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.QuoteWhereUniqueInput,
        include: Optional[types.QuoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Quote record.

        Parameters
        ----------
        where
            Quote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Quote model

        Returns
        -------
        prisma.models.Quote
            The found Quote record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quote = await Quote.prisma().find_unique(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.QuoteWhereUniqueInput,
        include: Optional[types.QuoteInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Quote record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Quote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Quote model

        Returns
        -------
        prisma.models.Quote
            The found Quote record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quote = await Quote.prisma().find_unique_or_raise(
            where={
                'id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuoteWhereInput] = None,
        cursor: Optional[types.QuoteWhereUniqueInput] = None,
        include: Optional[types.QuoteInclude] = None,
        order: Optional[Union[types.QuoteOrderByInput, List[types.QuoteOrderByInput]]] = None,
        distinct: Optional[List[types.QuoteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Quote records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Quote records returned
        skip
            Ignore the first N results
        where
            Quote filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Quote model
        order
            Order the returned Quote records by any field
        distinct
            Filter Quote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Quote]
            The list of all Quote records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Quote records
        quotes = await Quote.prisma().find_many(take=10)

        # find the first 5 Quote records ordered by the requestId field
        quotes = await Quote.prisma().find_many(
            take=5,
            order={
                'requestId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.QuoteWhereInput] = None,
        cursor: Optional[types.QuoteWhereUniqueInput] = None,
        include: Optional[types.QuoteInclude] = None,
        order: Optional[Union[types.QuoteOrderByInput, List[types.QuoteOrderByInput]]] = None,
        distinct: Optional[List[types.QuoteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Quote record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Quote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Quote model
        order
            Order the returned Quote records by any field
        distinct
            Filter Quote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Quote
            The first Quote record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Quote record ordered by the vendorId field
        quote = await Quote.prisma().find_first(
            skip=1,
            order={
                'vendorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.QuoteWhereInput] = None,
        cursor: Optional[types.QuoteWhereUniqueInput] = None,
        include: Optional[types.QuoteInclude] = None,
        order: Optional[Union[types.QuoteOrderByInput, List[types.QuoteOrderByInput]]] = None,
        distinct: Optional[List[types.QuoteScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Quote record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Quote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Quote model
        order
            Order the returned Quote records by any field
        distinct
            Filter Quote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Quote
            The first Quote record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Quote record ordered by the items field
        quote = await Quote.prisma().find_first_or_raise(
            skip=1,
            order={
                'items': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.QuoteUpdateInput,
        where: types.QuoteWhereUniqueInput,
        include: Optional[types.QuoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Quote record.

        Parameters
        ----------
        data
            Quote record data specifying what to update
        where
            Quote filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Quote model

        Returns
        -------
        prisma.models.Quote
            The updated Quote record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        quote = await Quote.prisma().update(
            where={
                'id': 'bjafcgbffc',
            },
            data={
                # data to update the Quote record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.QuoteWhereUniqueInput,
        data: types.QuoteUpsertInput,
        include: Optional[types.QuoteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Quote filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Quote model

        Returns
        -------
        prisma.models.Quote
            The created or updated Quote record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        quote = await Quote.prisma().upsert(
            where={
                'id': 'hihegjif',
            },
            data={
                'create': {
                    'id': 'hihegjif',
                    'orgId': 'bejfijgcfb',
                    'requestId': 'caifcbgii',
                    'vendorId': 'igaibbfgj',
                    'items': Json({'bggajdcbbi': True}),
                    'totalAmount': Decimal('525761943.73620'),
                },
                'update': {
                    'orgId': 'bejfijgcfb',
                    'requestId': 'caifcbgii',
                    'vendorId': 'igaibbfgj',
                    'items': Json({'bggajdcbbi': True}),
                    'totalAmount': Decimal('525761943.73620'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.QuoteUpdateManyMutationInput,
        where: types.QuoteWhereInput,
    ) -> int:
        """Update multiple Quote records

        Parameters
        ----------
        data
            Quote data to update the selected Quote records to
        where
            Filter to select the Quote records to update

        Returns
        -------
        int
            The total number of Quote records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Quote records
        total = await Quote.prisma().update_many(
            data={
                'totalAmount': Decimal('1398328302.85600')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuoteWhereInput] = None,
        cursor: Optional[types.QuoteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Quote records present in the database

        Parameters
        ----------
        select
            Select the Quote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Quote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.QuoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Quote.prisma().count()

        # results: prisma.types.QuoteCountAggregateOutput
        results = await Quote.prisma().count(
            select={
                '_all': True,
                'currency': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.QuoteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuoteWhereInput] = None,
        cursor: Optional[types.QuoteWhereUniqueInput] = None,
    ) -> types.QuoteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.QuoteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuoteWhereInput] = None,
        cursor: Optional[types.QuoteWhereUniqueInput] = None,
    ) -> Union[int, types.QuoteCountAggregateOutput]:
        """Count the number of Quote records present in the database

        Parameters
        ----------
        select
            Select the Quote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Quote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.QuoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Quote.prisma().count()

        # results: prisma.types.QuoteCountAggregateOutput
        results = await Quote.prisma().count(
            select={
                '_all': True,
                'deliveryDays': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.QuoteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.QuoteWhereInput] = None
    ) -> int:
        """Delete multiple Quote records.

        Parameters
        ----------
        where
            Optional Quote filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Quote records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Quote records
        total = await Quote.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.QuoteScalarFieldKeys'],
        *,
        where: Optional['types.QuoteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.QuoteAvgAggregateInput'] = None,
        sum: Optional['types.QuoteSumAggregateInput'] = None,
        min: Optional['types.QuoteMinAggregateInput'] = None,
        max: Optional['types.QuoteMaxAggregateInput'] = None,
        having: Optional['types.QuoteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.QuoteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.QuoteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.QuoteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.QuoteGroupByOutput']:
        """Group Quote records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Quote fields to group records by
        where
            Quote filter to select records
        take
            Limit the maximum number of Quote records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.QuoteGroupByOutput]
            A list of dictionaries representing the Quote record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Quote records by validUntil values
        # and count how many records are in each group
        results = await Quote.prisma().group_by(
            ['validUntil'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PaymentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Payment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Payment.prisma().query_raw(
            'SELECT * FROM Payment WHERE id = $1',
            'befcddgjce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Payment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Payment.prisma().query_first(
            'SELECT * FROM Payment WHERE orgId = $1',
            'bfhdbjjgfd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PaymentCreateInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Payment record.

        Parameters
        ----------
        data
            Payment record data
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created Payment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Payment record from just the required fields
        payment = await Payment.prisma().create(
            data={
                # data to create a Payment record
                'orgId': 'cabdjadaji',
                'requestId': 'faajgfadf',
                'quoteId': 'biaagcedjc',
                'amount': Decimal('2077067425.167211'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PaymentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Payment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Payment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Payment.prisma().create_many(
            data=[
                {
                    # data to create a Payment record
                    'orgId': 'jcgghhgdj',
                    'requestId': 'beehgcebbg',
                    'quoteId': 'bhdiaidiaf',
                    'amount': Decimal('340946258.60107'),
                },
                {
                    # data to create a Payment record
                    'orgId': 'cjagadcjg',
                    'requestId': 'bifficggej',
                    'quoteId': 'bgbbaajbic',
                    'amount': Decimal('446673791.30056'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Payment record.

        Parameters
        ----------
        where
            Payment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The deleted Payment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().delete(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Payment record.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Payment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique_or_raise(
            where={
                'id': 'ehabfhegh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Payment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N results
        where
            Payment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Payment]
            The list of all Payment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Payment records
        payments = await Payment.prisma().find_many(take=10)

        # find the first 5 Payment records ordered by the requestId field
        payments = await Payment.prisma().find_many(
            take=5,
            order={
                'requestId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Payment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the quoteId field
        payment = await Payment.prisma().find_first(
            skip=1,
            order={
                'quoteId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Payment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the amount field
        payment = await Payment.prisma().find_first_or_raise(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PaymentUpdateInput,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Payment record.

        Parameters
        ----------
        data
            Payment record data specifying what to update
        where
            Payment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The updated Payment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        payment = await Payment.prisma().update(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                # data to update the Payment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PaymentWhereUniqueInput,
        data: types.PaymentUpsertInput,
        include: Optional[types.PaymentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Payment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created or updated Payment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().upsert(
            where={
                'id': 'bfdgheeegf',
            },
            data={
                'create': {
                    'id': 'bfdgheeegf',
                    'orgId': 'cjagadcjg',
                    'requestId': 'bifficggej',
                    'quoteId': 'bgbbaajbic',
                    'amount': Decimal('446673791.30056'),
                },
                'update': {
                    'orgId': 'cjagadcjg',
                    'requestId': 'bifficggej',
                    'quoteId': 'bgbbaajbic',
                    'amount': Decimal('446673791.30056'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PaymentUpdateManyMutationInput,
        where: types.PaymentWhereInput,
    ) -> int:
        """Update multiple Payment records

        Parameters
        ----------
        data
            Payment data to update the selected Payment records to
        where
            Filter to select the Payment records to update

        Returns
        -------
        int
            The total number of Payment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Payment records
        total = await Payment.prisma().update_many(
            data={
                'currency': 'ececbijji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PaymentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> types.PaymentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PaymentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> Union[int, types.PaymentCountAggregateOutput]:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'stripePaymentIntentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PaymentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PaymentWhereInput] = None
    ) -> int:
        """Delete multiple Payment records.

        Parameters
        ----------
        where
            Optional Payment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Payment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Payment records
        total = await Payment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PaymentScalarFieldKeys'],
        *,
        where: Optional['types.PaymentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PaymentAvgAggregateInput'] = None,
        sum: Optional['types.PaymentSumAggregateInput'] = None,
        min: Optional['types.PaymentMinAggregateInput'] = None,
        max: Optional['types.PaymentMaxAggregateInput'] = None,
        having: Optional['types.PaymentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PaymentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PaymentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PaymentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PaymentGroupByOutput']:
        """Group Payment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Payment fields to group records by
        where
            Payment filter to select records
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PaymentGroupByOutput]
            A list of dictionaries representing the Payment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Payment records by stripeChargeId values
        # and count how many records are in each group
        results = await Payment.prisma().group_by(
            ['stripeChargeId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuditLog.prisma().query_raw(
            'SELECT * FROM AuditLog WHERE id = $1',
            'cbcfgdcdhf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuditLog.prisma().query_first(
            'SELECT * FROM AuditLog WHERE orgId = $1',
            'fdgjfbhia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuditLogCreateInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuditLog record from just the required fields
        auditlog = await AuditLog.prisma().create(
            data={
                # data to create a AuditLog record
                'orgId': 'jcehcdchh',
                'action': 'bgcbjdhjcc',
                'entityType': 'bieiidcabj',
                'entityId': 'bjcbfcieaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a AuditLog record
                    'orgId': 'cbaaechiej',
                    'action': 'iejbeaaeg',
                    'entityType': 'jcibfcbhf',
                    'entityId': 'chdadcaga',
                },
                {
                    # data to create a AuditLog record
                    'orgId': 'jicieifbh',
                    'action': 'fbahdheji',
                    'entityType': 'cbbheiicgh',
                    'entityId': 'beabjeejdg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The deleted AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().delete(
            where={
                'id': 'bcjhgahffd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N results
        where
            AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuditLog]
            The list of all AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuditLog records
        auditlogs = await AuditLog.prisma().find_many(take=10)

        # find the first 5 AuditLog records ordered by the action field
        auditlogs = await AuditLog.prisma().find_many(
            take=5,
            order={
                'action': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the entityType field
        auditlog = await AuditLog.prisma().find_first(
            skip=1,
            order={
                'entityType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the entityId field
        auditlog = await AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'entityId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuditLogUpdateInput,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data specifying what to update
        where
            AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The updated AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().update(
            where={
                'id': 'bgjgecfejc',
            },
            data={
                # data to update the AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuditLogWhereUniqueInput,
        data: types.AuditLogUpsertInput,
        include: Optional[types.AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created or updated AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().upsert(
            where={
                'id': 'bgjcgchib',
            },
            data={
                'create': {
                    'id': 'bgjcgchib',
                    'orgId': 'jicieifbh',
                    'action': 'fbahdheji',
                    'entityType': 'cbbheiicgh',
                    'entityId': 'beabjeejdg',
                },
                'update': {
                    'orgId': 'jicieifbh',
                    'action': 'fbahdheji',
                    'entityType': 'cbbheiicgh',
                    'entityId': 'beabjeejdg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuditLogUpdateManyMutationInput,
        where: types.AuditLogWhereInput,
    ) -> int:
        """Update multiple AuditLog records

        Parameters
        ----------
        data
            AuditLog data to update the selected AuditLog records to
        where
            Filter to select the AuditLog records to update

        Returns
        -------
        int
            The total number of AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuditLog records
        total = await AuditLog.prisma().update_many(
            data={
                'userId': 'bacdaibgfa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'oldValues': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> types.AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.AuditLogCountAggregateOutput]:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'newValues': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple AuditLog records.

        Parameters
        ----------
        where
            Optional AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuditLog records
        total = await AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.AuditLogSumAggregateInput'] = None,
        min: Optional['types.AuditLogMinAggregateInput'] = None,
        max: Optional['types.AuditLogMaxAggregateInput'] = None,
        having: Optional['types.AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuditLogGroupByOutput']:
        """Group AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuditLog fields to group records by
        where
            AuditLog filter to select records
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuditLogGroupByOutput]
            A list of dictionaries representing the AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuditLog records by metadata values
        # and count how many records are in each group
        results = await AuditLog.prisma().group_by(
            ['metadata'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailThreadActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailThread]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailThread.prisma().query_raw(
            'SELECT * FROM EmailThread WHERE id = $1',
            'dchgibach',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailThread
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailThread.prisma().query_first(
            'SELECT * FROM EmailThread WHERE orgId = $1',
            'fchheijjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailThreadCreateInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailThread record.

        Parameters
        ----------
        data
            EmailThread record data
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The created EmailThread record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailThread record from just the required fields
        emailthread = await EmailThread.prisma().create(
            data={
                # data to create a EmailThread record
                'orgId': 'cacjdfhejh',
                'gmailThreadId': 'bdbifjhbbi',
                'subject': 'cbccbbcdfb',
                'participants': Json({'bacejedaca': True}),
                'lastMessageAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailThreadCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailThread records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailThread record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailThread.prisma().create_many(
            data=[
                {
                    # data to create a EmailThread record
                    'orgId': 'bhbhdahfaj',
                    'gmailThreadId': 'bfjibceaec',
                    'subject': 'ibhgcdbgd',
                    'participants': Json({'badaffhddg': True}),
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a EmailThread record
                    'orgId': 'bbdbfcfihd',
                    'gmailThreadId': 'cbagggbji',
                    'subject': 'bchgafhjed',
                    'participants': Json({'heffgjdei': True}),
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailThread record.

        Parameters
        ----------
        where
            EmailThread filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The deleted EmailThread record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().delete(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailThread record.

        Parameters
        ----------
        where
            EmailThread filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The found EmailThread record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().find_unique(
            where={
                'id': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailThread record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailThread filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The found EmailThread record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().find_unique_or_raise(
            where={
                'id': 'bfcgifeged',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
        include: Optional[types.EmailThreadInclude] = None,
        order: Optional[Union[types.EmailThreadOrderByInput, List[types.EmailThreadOrderByInput]]] = None,
        distinct: Optional[List[types.EmailThreadScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailThread records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailThread records returned
        skip
            Ignore the first N results
        where
            EmailThread filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailThread model
        order
            Order the returned EmailThread records by any field
        distinct
            Filter EmailThread records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailThread]
            The list of all EmailThread records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailThread records
        emailthreads = await EmailThread.prisma().find_many(take=10)

        # find the first 5 EmailThread records ordered by the gmailThreadId field
        emailthreads = await EmailThread.prisma().find_many(
            take=5,
            order={
                'gmailThreadId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
        include: Optional[types.EmailThreadInclude] = None,
        order: Optional[Union[types.EmailThreadOrderByInput, List[types.EmailThreadOrderByInput]]] = None,
        distinct: Optional[List[types.EmailThreadScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailThread record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailThread filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailThread model
        order
            Order the returned EmailThread records by any field
        distinct
            Filter EmailThread records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailThread
            The first EmailThread record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailThread record ordered by the subject field
        emailthread = await EmailThread.prisma().find_first(
            skip=1,
            order={
                'subject': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
        include: Optional[types.EmailThreadInclude] = None,
        order: Optional[Union[types.EmailThreadOrderByInput, List[types.EmailThreadOrderByInput]]] = None,
        distinct: Optional[List[types.EmailThreadScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailThread record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailThread filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailThread model
        order
            Order the returned EmailThread records by any field
        distinct
            Filter EmailThread records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailThread
            The first EmailThread record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailThread record ordered by the participants field
        emailthread = await EmailThread.prisma().find_first_or_raise(
            skip=1,
            order={
                'participants': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailThreadUpdateInput,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailThread record.

        Parameters
        ----------
        data
            EmailThread record data specifying what to update
        where
            EmailThread filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The updated EmailThread record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().update(
            where={
                'id': 'jfiahhbae',
            },
            data={
                # data to update the EmailThread record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailThreadWhereUniqueInput,
        data: types.EmailThreadUpsertInput,
        include: Optional[types.EmailThreadInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailThread filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The created or updated EmailThread record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().upsert(
            where={
                'id': 'bfbdafajcb',
            },
            data={
                'create': {
                    'id': 'bfbdafajcb',
                    'orgId': 'bbdbfcfihd',
                    'gmailThreadId': 'cbagggbji',
                    'subject': 'bchgafhjed',
                    'participants': Json({'heffgjdei': True}),
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'orgId': 'bbdbfcfihd',
                    'gmailThreadId': 'cbagggbji',
                    'subject': 'bchgafhjed',
                    'participants': Json({'heffgjdei': True}),
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailThreadUpdateManyMutationInput,
        where: types.EmailThreadWhereInput,
    ) -> int:
        """Update multiple EmailThread records

        Parameters
        ----------
        data
            EmailThread data to update the selected EmailThread records to
        where
            Filter to select the EmailThread records to update

        Returns
        -------
        int
            The total number of EmailThread records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailThread records
        total = await EmailThread.prisma().update_many(
            data={
                'requestId': 'caeghehde'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailThread records present in the database

        Parameters
        ----------
        select
            Select the EmailThread fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailThread filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailThreadCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailThread.prisma().count()

        # results: prisma.types.EmailThreadCountAggregateOutput
        results = await EmailThread.prisma().count(
            select={
                '_all': True,
                'lastMessageAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailThreadCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
    ) -> types.EmailThreadCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailThreadCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
    ) -> Union[int, types.EmailThreadCountAggregateOutput]:
        """Count the number of EmailThread records present in the database

        Parameters
        ----------
        select
            Select the EmailThread fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailThread filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailThreadCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailThread.prisma().count()

        # results: prisma.types.EmailThreadCountAggregateOutput
        results = await EmailThread.prisma().count(
            select={
                '_all': True,
                'messageCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailThreadCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailThreadWhereInput] = None
    ) -> int:
        """Delete multiple EmailThread records.

        Parameters
        ----------
        where
            Optional EmailThread filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailThread records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailThread records
        total = await EmailThread.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailThreadScalarFieldKeys'],
        *,
        where: Optional['types.EmailThreadWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailThreadAvgAggregateInput'] = None,
        sum: Optional['types.EmailThreadSumAggregateInput'] = None,
        min: Optional['types.EmailThreadMinAggregateInput'] = None,
        max: Optional['types.EmailThreadMaxAggregateInput'] = None,
        having: Optional['types.EmailThreadScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailThreadCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailThreadScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailThreadScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailThreadGroupByOutput']:
        """Group EmailThread records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailThread fields to group records by
        where
            EmailThread filter to select records
        take
            Limit the maximum number of EmailThread records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailThreadGroupByOutput]
            A list of dictionaries representing the EmailThread record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailThread records by metadata values
        # and count how many records are in each group
        results = await EmailThread.prisma().group_by(
            ['metadata'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailMessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailMessage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailMessage.prisma().query_raw(
            'SELECT * FROM EmailMessage WHERE id = $1',
            'caghgfbggd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailMessage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailMessage.prisma().query_first(
            'SELECT * FROM EmailMessage WHERE threadId = $1',
            'bbidjbbjaa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailMessageCreateInput,
        include: Optional[types.EmailMessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailMessage record.

        Parameters
        ----------
        data
            EmailMessage record data
        include
            Specifies which relations should be loaded on the returned EmailMessage model

        Returns
        -------
        prisma.models.EmailMessage
            The created EmailMessage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailMessage record from just the required fields
        emailmessage = await EmailMessage.prisma().create(
            data={
                # data to create a EmailMessage record
                'threadId': 'bfijhaejdd',
                'gmailMessageId': 'bcedehfiji',
                'sender': 'bdgjicijhb',
                'to': Json({'bghifjdeia': True}),
                'subject': 'eadfcbbcb',
                'body': 'geihgahba',
                'receivedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailMessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailMessage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailMessage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailMessage.prisma().create_many(
            data=[
                {
                    # data to create a EmailMessage record
                    'threadId': 'gahdcdhbj',
                    'gmailMessageId': 'begiijahea',
                    'sender': 'gcjadjaaf',
                    'to': Json({'bcbebgiaic': True}),
                    'subject': 'ijigbdcbj',
                    'body': 'gfidhicai',
                    'receivedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a EmailMessage record
                    'threadId': 'jfegcaafh',
                    'gmailMessageId': 'bcbeiajjfa',
                    'sender': 'baehicaajf',
                    'to': Json({'bdachdeiga': True}),
                    'subject': 'ijdafccef',
                    'body': 'ciaaiddag',
                    'receivedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailMessageWhereUniqueInput,
        include: Optional[types.EmailMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailMessage record.

        Parameters
        ----------
        where
            EmailMessage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailMessage model

        Returns
        -------
        prisma.models.EmailMessage
            The deleted EmailMessage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailmessage = await EmailMessage.prisma().delete(
            where={
                'id': 'fejggijff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailMessageWhereUniqueInput,
        include: Optional[types.EmailMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailMessage record.

        Parameters
        ----------
        where
            EmailMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailMessage model

        Returns
        -------
        prisma.models.EmailMessage
            The found EmailMessage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailmessage = await EmailMessage.prisma().find_unique(
            where={
                'id': 'hghjaaai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailMessageWhereUniqueInput,
        include: Optional[types.EmailMessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailMessage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailMessage model

        Returns
        -------
        prisma.models.EmailMessage
            The found EmailMessage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailmessage = await EmailMessage.prisma().find_unique_or_raise(
            where={
                'id': 'cajicjjdef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailMessageWhereInput] = None,
        cursor: Optional[types.EmailMessageWhereUniqueInput] = None,
        include: Optional[types.EmailMessageInclude] = None,
        order: Optional[Union[types.EmailMessageOrderByInput, List[types.EmailMessageOrderByInput]]] = None,
        distinct: Optional[List[types.EmailMessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailMessage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailMessage records returned
        skip
            Ignore the first N results
        where
            EmailMessage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailMessage model
        order
            Order the returned EmailMessage records by any field
        distinct
            Filter EmailMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailMessage]
            The list of all EmailMessage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailMessage records
        emailmessages = await EmailMessage.prisma().find_many(take=10)

        # find the first 5 EmailMessage records ordered by the gmailMessageId field
        emailmessages = await EmailMessage.prisma().find_many(
            take=5,
            order={
                'gmailMessageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailMessageWhereInput] = None,
        cursor: Optional[types.EmailMessageWhereUniqueInput] = None,
        include: Optional[types.EmailMessageInclude] = None,
        order: Optional[Union[types.EmailMessageOrderByInput, List[types.EmailMessageOrderByInput]]] = None,
        distinct: Optional[List[types.EmailMessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailMessage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailMessage model
        order
            Order the returned EmailMessage records by any field
        distinct
            Filter EmailMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailMessage
            The first EmailMessage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailMessage record ordered by the sender field
        emailmessage = await EmailMessage.prisma().find_first(
            skip=1,
            order={
                'sender': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailMessageWhereInput] = None,
        cursor: Optional[types.EmailMessageWhereUniqueInput] = None,
        include: Optional[types.EmailMessageInclude] = None,
        order: Optional[Union[types.EmailMessageOrderByInput, List[types.EmailMessageOrderByInput]]] = None,
        distinct: Optional[List[types.EmailMessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailMessage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailMessage model
        order
            Order the returned EmailMessage records by any field
        distinct
            Filter EmailMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailMessage
            The first EmailMessage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailMessage record ordered by the to field
        emailmessage = await EmailMessage.prisma().find_first_or_raise(
            skip=1,
            order={
                'to': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailMessageUpdateInput,
        where: types.EmailMessageWhereUniqueInput,
        include: Optional[types.EmailMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailMessage record.

        Parameters
        ----------
        data
            EmailMessage record data specifying what to update
        where
            EmailMessage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailMessage model

        Returns
        -------
        prisma.models.EmailMessage
            The updated EmailMessage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailmessage = await EmailMessage.prisma().update(
            where={
                'id': 'cefjaadec',
            },
            data={
                # data to update the EmailMessage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailMessageWhereUniqueInput,
        data: types.EmailMessageUpsertInput,
        include: Optional[types.EmailMessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailMessage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailMessage model

        Returns
        -------
        prisma.models.EmailMessage
            The created or updated EmailMessage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailmessage = await EmailMessage.prisma().upsert(
            where={
                'id': 'ibbigdigd',
            },
            data={
                'create': {
                    'id': 'ibbigdigd',
                    'threadId': 'jfegcaafh',
                    'gmailMessageId': 'bcbeiajjfa',
                    'sender': 'baehicaajf',
                    'to': Json({'bdachdeiga': True}),
                    'subject': 'ijdafccef',
                    'body': 'ciaaiddag',
                    'receivedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'threadId': 'jfegcaafh',
                    'gmailMessageId': 'bcbeiajjfa',
                    'sender': 'baehicaajf',
                    'to': Json({'bdachdeiga': True}),
                    'subject': 'ijdafccef',
                    'body': 'ciaaiddag',
                    'receivedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailMessageUpdateManyMutationInput,
        where: types.EmailMessageWhereInput,
    ) -> int:
        """Update multiple EmailMessage records

        Parameters
        ----------
        data
            EmailMessage data to update the selected EmailMessage records to
        where
            Filter to select the EmailMessage records to update

        Returns
        -------
        int
            The total number of EmailMessage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailMessage records
        total = await EmailMessage.prisma().update_many(
            data={
                'subject': 'bdiiiabbii'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailMessageWhereInput] = None,
        cursor: Optional[types.EmailMessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailMessage records present in the database

        Parameters
        ----------
        select
            Select the EmailMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailMessage.prisma().count()

        # results: prisma.types.EmailMessageCountAggregateOutput
        results = await EmailMessage.prisma().count(
            select={
                '_all': True,
                'body': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailMessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailMessageWhereInput] = None,
        cursor: Optional[types.EmailMessageWhereUniqueInput] = None,
    ) -> types.EmailMessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailMessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailMessageWhereInput] = None,
        cursor: Optional[types.EmailMessageWhereUniqueInput] = None,
    ) -> Union[int, types.EmailMessageCountAggregateOutput]:
        """Count the number of EmailMessage records present in the database

        Parameters
        ----------
        select
            Select the EmailMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailMessage.prisma().count()

        # results: prisma.types.EmailMessageCountAggregateOutput
        results = await EmailMessage.prisma().count(
            select={
                '_all': True,
                'isProcessed': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailMessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailMessageWhereInput] = None
    ) -> int:
        """Delete multiple EmailMessage records.

        Parameters
        ----------
        where
            Optional EmailMessage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailMessage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailMessage records
        total = await EmailMessage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailMessageScalarFieldKeys'],
        *,
        where: Optional['types.EmailMessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailMessageAvgAggregateInput'] = None,
        sum: Optional['types.EmailMessageSumAggregateInput'] = None,
        min: Optional['types.EmailMessageMinAggregateInput'] = None,
        max: Optional['types.EmailMessageMaxAggregateInput'] = None,
        having: Optional['types.EmailMessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailMessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailMessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailMessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailMessageGroupByOutput']:
        """Group EmailMessage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailMessage fields to group records by
        where
            EmailMessage filter to select records
        take
            Limit the maximum number of EmailMessage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailMessageGroupByOutput]
            A list of dictionaries representing the EmailMessage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailMessage records by extractedData values
        # and count how many records are in each group
        results = await EmailMessage.prisma().group_by(
            ['extractedData'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WorkflowExecutionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WorkflowExecution]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WorkflowExecution.prisma().query_raw(
            'SELECT * FROM WorkflowExecution WHERE id = $1',
            'hfcfhhadh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WorkflowExecution
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WorkflowExecution.prisma().query_first(
            'SELECT * FROM WorkflowExecution WHERE orgId = $1',
            'bbihggdcji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WorkflowExecutionCreateInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> _PrismaModelT:
        """Create a new WorkflowExecution record.

        Parameters
        ----------
        data
            WorkflowExecution record data
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The created WorkflowExecution record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WorkflowExecution record from just the required fields
        workflowexecution = await WorkflowExecution.prisma().create(
            data={
                # data to create a WorkflowExecution record
                'orgId': 'hgjgibdgd',
                'workflowType': 'bcbecjfice',
                'entityId': 'bacbebhjjd',
                'entityType': 'dfbfaddhe',
                'currentState': 'bdcbbieibf',
                'stateData': Json({'dgjhdcggi': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WorkflowExecutionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WorkflowExecution records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WorkflowExecution record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WorkflowExecution.prisma().create_many(
            data=[
                {
                    # data to create a WorkflowExecution record
                    'orgId': 'bbjbcdfabd',
                    'workflowType': 'gchfgbcec',
                    'entityId': 'bihcjfcjah',
                    'entityType': 'bhjdcicaii',
                    'currentState': 'bibedjhcej',
                    'stateData': Json({'bjcdajabfa': True}),
                },
                {
                    # data to create a WorkflowExecution record
                    'orgId': 'bchhceeeff',
                    'workflowType': 'bbgaifhdaa',
                    'entityId': 'dgbcdaegb',
                    'entityType': 'beagfbbjig',
                    'currentState': 'beicihhijb',
                    'stateData': Json({'fgggcdcjg': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WorkflowExecution record.

        Parameters
        ----------
        where
            WorkflowExecution filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The deleted WorkflowExecution record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().delete(
            where={
                'id': 'ccjbbjigf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WorkflowExecution record.

        Parameters
        ----------
        where
            WorkflowExecution filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The found WorkflowExecution record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().find_unique(
            where={
                'id': 'bhfaabbaha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WorkflowExecution record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WorkflowExecution filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The found WorkflowExecution record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().find_unique_or_raise(
            where={
                'id': 'ebajedhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
        include: Optional[types.WorkflowExecutionInclude] = None,
        order: Optional[Union[types.WorkflowExecutionOrderByInput, List[types.WorkflowExecutionOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowExecutionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WorkflowExecution records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WorkflowExecution records returned
        skip
            Ignore the first N results
        where
            WorkflowExecution filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model
        order
            Order the returned WorkflowExecution records by any field
        distinct
            Filter WorkflowExecution records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WorkflowExecution]
            The list of all WorkflowExecution records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WorkflowExecution records
        workflowexecutions = await WorkflowExecution.prisma().find_many(take=10)

        # find the first 5 WorkflowExecution records ordered by the workflowType field
        workflowexecutions = await WorkflowExecution.prisma().find_many(
            take=5,
            order={
                'workflowType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
        include: Optional[types.WorkflowExecutionInclude] = None,
        order: Optional[Union[types.WorkflowExecutionOrderByInput, List[types.WorkflowExecutionOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowExecutionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WorkflowExecution record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model
        order
            Order the returned WorkflowExecution records by any field
        distinct
            Filter WorkflowExecution records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WorkflowExecution
            The first WorkflowExecution record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WorkflowExecution record ordered by the entityId field
        workflowexecution = await WorkflowExecution.prisma().find_first(
            skip=1,
            order={
                'entityId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
        include: Optional[types.WorkflowExecutionInclude] = None,
        order: Optional[Union[types.WorkflowExecutionOrderByInput, List[types.WorkflowExecutionOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowExecutionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WorkflowExecution record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model
        order
            Order the returned WorkflowExecution records by any field
        distinct
            Filter WorkflowExecution records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WorkflowExecution
            The first WorkflowExecution record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WorkflowExecution record ordered by the entityType field
        workflowexecution = await WorkflowExecution.prisma().find_first_or_raise(
            skip=1,
            order={
                'entityType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WorkflowExecutionUpdateInput,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WorkflowExecution record.

        Parameters
        ----------
        data
            WorkflowExecution record data specifying what to update
        where
            WorkflowExecution filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The updated WorkflowExecution record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().update(
            where={
                'id': 'jajacedge',
            },
            data={
                # data to update the WorkflowExecution record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        data: types.WorkflowExecutionUpsertInput,
        include: Optional[types.WorkflowExecutionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WorkflowExecution filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The created or updated WorkflowExecution record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().upsert(
            where={
                'id': 'hffgbabgf',
            },
            data={
                'create': {
                    'id': 'hffgbabgf',
                    'orgId': 'bchhceeeff',
                    'workflowType': 'bbgaifhdaa',
                    'entityId': 'dgbcdaegb',
                    'entityType': 'beagfbbjig',
                    'currentState': 'beicihhijb',
                    'stateData': Json({'fgggcdcjg': True}),
                },
                'update': {
                    'orgId': 'bchhceeeff',
                    'workflowType': 'bbgaifhdaa',
                    'entityId': 'dgbcdaegb',
                    'entityType': 'beagfbbjig',
                    'currentState': 'beicihhijb',
                    'stateData': Json({'fgggcdcjg': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WorkflowExecutionUpdateManyMutationInput,
        where: types.WorkflowExecutionWhereInput,
    ) -> int:
        """Update multiple WorkflowExecution records

        Parameters
        ----------
        data
            WorkflowExecution data to update the selected WorkflowExecution records to
        where
            Filter to select the WorkflowExecution records to update

        Returns
        -------
        int
            The total number of WorkflowExecution records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WorkflowExecution records
        total = await WorkflowExecution.prisma().update_many(
            data={
                'currentState': 'biacbiieja'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WorkflowExecution records present in the database

        Parameters
        ----------
        select
            Select the WorkflowExecution fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkflowExecutionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WorkflowExecution.prisma().count()

        # results: prisma.types.WorkflowExecutionCountAggregateOutput
        results = await WorkflowExecution.prisma().count(
            select={
                '_all': True,
                'stateData': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WorkflowExecutionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
    ) -> types.WorkflowExecutionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WorkflowExecutionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
    ) -> Union[int, types.WorkflowExecutionCountAggregateOutput]:
        """Count the number of WorkflowExecution records present in the database

        Parameters
        ----------
        select
            Select the WorkflowExecution fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkflowExecutionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WorkflowExecution.prisma().count()

        # results: prisma.types.WorkflowExecutionCountAggregateOutput
        results = await WorkflowExecution.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WorkflowExecutionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WorkflowExecutionWhereInput] = None
    ) -> int:
        """Delete multiple WorkflowExecution records.

        Parameters
        ----------
        where
            Optional WorkflowExecution filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WorkflowExecution records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WorkflowExecution records
        total = await WorkflowExecution.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WorkflowExecutionScalarFieldKeys'],
        *,
        where: Optional['types.WorkflowExecutionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WorkflowExecutionAvgAggregateInput'] = None,
        sum: Optional['types.WorkflowExecutionSumAggregateInput'] = None,
        min: Optional['types.WorkflowExecutionMinAggregateInput'] = None,
        max: Optional['types.WorkflowExecutionMaxAggregateInput'] = None,
        having: Optional['types.WorkflowExecutionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WorkflowExecutionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WorkflowExecutionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WorkflowExecutionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WorkflowExecutionGroupByOutput']:
        """Group WorkflowExecution records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WorkflowExecution fields to group records by
        where
            WorkflowExecution filter to select records
        take
            Limit the maximum number of WorkflowExecution records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WorkflowExecutionGroupByOutput]
            A list of dictionaries representing the WorkflowExecution record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WorkflowExecution records by startedAt values
        # and count how many records are in each group
        results = await WorkflowExecution.prisma().group_by(
            ['startedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models